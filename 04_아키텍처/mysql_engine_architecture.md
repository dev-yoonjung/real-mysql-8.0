# 04 아키텍처

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL의 전체 구조

![MYSQL 서버의 전체 구조](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/cae712d0-4674-486b-b93e-61b009dfe773)

#### 4.1.1.1 MySQL 엔진

- MySQL 엔진 = 커넥션 핸들러 + SQL 파서 및 전처리기 + 옵티마이저
  - 커넥션 핸들러: 클라이언트로부터의 접속 및 쿼리 요청 처리
  - SQL 파서: SQL 문장 분석
  - 옵티마이저: 쿼리 최적화
- ANSI SQL 문법을 지원하기 때문에 다른 DBMS와 호환 가능

#### 4.1.1.2 스토리지 엔진

- 스토리지 엔진: 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 엔진
- MySQL 엔진과 달리 여러 개를 동시에 사용 가능

#### 4.1.1.3 핸들러 API

- 핸들러(Handler): MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 얅이야 할 때 각 스토리지 엔진에 쓰기 또는 읽기 요청을 하는 것
- 핸들러 API: 요청을 할 때 사용되는 API

### 4.1.2 MySQL 스레딩 구조

![MySQL 스레딩 구조](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/d31ff80e-6c39-4a00-b7fd-6f4dea6c02cc)

- MySQL 서버는 프로세스 기반이 아닌 **스레드 기반**으로 작동
- **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드**로 구분

#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

- 각 클라이언트 사용자가 **요청하는 쿼리 문장 처리**
- 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 스레드 캐시(Thread Cache)로 되돌아감
  - 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 됨
    - 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴
  - 버퍼나 캐시에 데이터가 없을 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 가져와 작업 처리

#### 4.1.2.2 백그라운드 스레드

- `InnoDB`는 여러 가지 작업이 백그라운드로 처리됨
  - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 5.5 버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정 가능
  - `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 설정
  - 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드 개수는 많이 설정할 필요가 없음
  - 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4정도, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을만큼 설정
- 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 지연 불가

### 4.1.3 메모리 할당 및 사용 구조

![메모리 할당 및 사용 구조](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/864ea67e-ba26-4bd7-ac7a-438e3ddbab8d)

- 글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 **스레드가 공유해서 사용하는 공간인지 여부**에 따라 구분

#### 4.1.3.1 글로벌 메모리 영역

- 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
- 생성된 글로벌 영역이 N개라 하더라도 **모든 스레드에 의해 공유**

#### 4.1.3.2 로컬 메모리 영역

- MySQL 서버상에 존재하는 **클라이언트 스레드가 쿼리를 처리하는 데 사용**하는 메모리 영역
- 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 로컬 메모리 영역을 **세션 메모리 영역**이라고도 표현함
- 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않음
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차 하지 않을 수도 있음
  - `Sort Buffer`, `Join Buffer`
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간도 있음
  - `Connection Buffer`, `Result Buffer`
- 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간도 있음
  - `Sort Buffer`, `Join Buffer`

### 4.1.4 플러그인 스토리지 엔진 모델

![MySQL 플러그인 모델](https://github.com/dev-yoonjung/e-wallet/assets/98807166/9376726c-2864-404a-b6f2-3225a63acc45)

- 수많은 사용자의 요구 조건을 만족시키기 위해 기본적으로 제공되는 스토리지 엔진 이외에 부가적인 기능을 더 제공하는 스토리지 엔진을 개발하여 **플러그인 형태로 제공**
  - 인증이나 전문 검색 파서 또는 쿼리 재작성과 같은 플러그인이 있으며, 비밀번호 검증과 커넥션 제어 등에 관련된 다양한 플러그인이 제공
  - 기존 MySQL 서버에서 제공하던 기능들을 확장하거나 완전히 새로운 기능들을 플러그인을 이용해 구현 가능

### 4.1.5 컴포넌트

- MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처 지원
- 컴포넌트는 아래의 플러그인의 단점을 보안함
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
  - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화되지 않음)
  - 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

### 4.1.6 쿼리 실행구조

![쿼리 실행 구조](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/c297f4b0-ff7f-416f-9e19-221fc8ca030e)

#### 4.1.6.1 쿼리 파서

- 사용자 요청으로 들어온 쿼리를 토큰(MySQL이 인식할 수 있는 최소 단위나 어휘 기호)으로 분리해 트리 형태의 구조로 만들어내는 작업
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되어 사용자에게 오류 메시지 전달

#### 4.1.6.2 전처리기

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐

#### 4.1.6.3 옵티마이저

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할

#### 4.1.6.4 실행 엔진

- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행

> **실행엔진 실행 예시**
>
> GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 가정
>
> 1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
> 2. 다시 실행 엔진은 `WHERE` 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
> 3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
> 4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
> 5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

#### 4.1.6.5 핸들러(스토리지 엔진)

- MySQL 서버 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 스토리지 엔진을 의미

### 4.1.7 스레드 풀

- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 **서버의 자원 소모를 줄이는 것이 목적**
- CPU가 제한된 수의 스레드만으로 처리하도록 적절히 유도한다면 불필요한 컨텍스트 스위치(Context Switch)를 줄여 오버헤드를 낮출 수 있음
  - 일반적으로 CPU 코어의 개수와 `thread_pool_size` 개수와 동일하게 설정
- 엔터프라이즈 에디션에서만 제공하는 기능
  - 커뮤니티 에디션에서도 스레드 풀 기능을 사용하고자 한다면 동일 버전의 Percona Server에서 스레드 풀 플러그인 라이브러리(thread_pool.so)를 설치해서 사용

### 4.1.8 트랜잭션 지원 메타데이터

> **메타데이터**
>
> 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보

- MySQL 8.0 버전부터 메타데이터 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선됨
  - 시스템 테이블(MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들의 묶음)을 모두 InnoDB 스토리지 엔진을 사용하도록 개선
- 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 `mysql` DB에 저장
  - `mysql` DB는 통째로 `mysql.ibd`라는 이름의 테이블스페이스에 저장

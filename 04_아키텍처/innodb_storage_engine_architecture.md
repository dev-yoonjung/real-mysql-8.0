# 04 아키텍처

## 4.2 InnoDB 스토리지 엔진 아키텍처

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
  - 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남

![InnoDB 구조](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/681d98c4-4029-45d7-b777-dcf3ed525664)

### 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장됨
  - 프라이머리 키 값의 순서대로 디스크에 저장
  - 세컨더리 인덱스는 프라이머리 키의 값을 논리적인 주소로 사용
  - 프라이머리 키가 클러스터링 인덱스이기 때문에 레인지 스캔은 상당히 빨리 처리됨

### 4.2.2 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능
- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많음

### 4.2.3 MVCC(Multi Version Concurrency Control)

> **멀티 버전(Multi Version)**
>
> 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- **잠금을 사용하지 않는 일관된 읽기를 제공**하는 것이 목적
- InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현하고 있음
  - 격리 수준(Isolation Level)이 `READ_UNCOMMITED`의 경우 InnoDB 버퍼 풀이나 데이터 파일로 부터 데이터를 읽어 반환
  - 격리 수준(Isolation Level)이 `READ_COMMITTED`, `REPEATABLE_READ`의 경우 InnoDB 버퍼 풀이나 데이터 파일 대신 변경되기 전 내용을 보관하고 있는 **언두 영역**의 데이터를 반환
- 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 하며, 자연히 언두 영역이 저장되는 시스템 테이블스페이스의 공간이 많이 늘어나는 상황이 발생할 수 있음

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행
  - 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음

![변경 중인 레코드 읽기](https://github.com/dev-yoonjung/real-mysql-8.0/assets/98807166/6f528232-40e5-47d3-a5fb-7bd2ee8eb85b)

### 4.2.5 자동 데드락 감지

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 강제로 종료함
  - 언두 로그 레코드를 더 적게 가진 트랜젝션이 일반적으로 롤백 대상
- 동시 처리 스레드가 매우 많은 경우 데드랑 감지 스레드는 더 많은 CPU 자원을 소모함
  - `innodb_deadlock_detect`를 `OFF`로 설정하면 데드락 감지 스레드는 더는 작동하지 않게 됨
  - `innodb_lock_wait_timeout`를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환함
    - 기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장함

### 4.2.6 자동화된 장애 복구

- InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있는데, 그러한 메커니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 **일련의 복구 작업이 자동으로 진행**됨
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행하는데, 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료됨
  - 디스크나 서버 하드웨어 이슈가 주요 케이스
  - 이 때 MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정하여 MySQL을 실행
    - 1~6의 값을 가지며 단계 별로 선별적 자동 복구를 진행할 수 있음
    - [참고링크](https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html)

### 4.2.7 InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함

#### 4.2.7.1 버퍼 풀의 크기 설정
